#!/usr/bin/env python

import os, os.path, re, sys
import mmap
import subprocess
from stat import *

g_reg = r''
g_filePat = r''
g_includeAll = False 
g_caseFlag = 0

g_Col_Reset = '\x1b[m\x1b[K'
g_Col_MagentaStart = '\x1b[35m\x1b[K'
g_Col_CyanStart = '\x1b[36m\x1b[K'
g_Col_GreenStart = '\x1b[32m\x1b[K'
g_Col_RedStart = '\x1b[01;31m\x1b[K'

g_excludeFilesPatternList =  [r'^\..+', r'.*~$', r'.*\.bak$', r'.*_{1,2}$', r'.*\.old$']
g_excludeFilesPattern = r'|'.join( [ '(' + group_them + ')' for group_them in g_excludeFilesPatternList ] )

if sys.stdout.isatty():
  g_isTty = True
  # Magenta_filenameCyan_:Green_linenoCyan_:White_line
  g_PaternFormat = g_Col_MagentaStart +'%s'+ g_Col_Reset + g_Col_CyanStart +':'+ g_Col_Reset\
  + g_Col_GreenStart +'%d'+ g_Col_Reset + g_Col_CyanStart +':'+g_Col_Reset +'%s'
else:
  g_isTty = False
  # filename:lineno:line
  g_PaternFormat = '%s:%d:%s'


class DataHolder(object):
  def __init__(self, value=None, name='value'):
    self._name = name
    self.set(value)

  def __call__(self, value):
    return self.set(value)

  def set(self, value):
    setattr(self, self._name, value)
    return value

  def get(self):
    return getattr(self, self._name)



def processDir(top, searcher):
  for f in os.listdir(top):
    path = os.path.join ( top, f )
    try:
      mode = os.stat( path ).st_mode
    except OSError, why:
      sys.stderr.write( why.filename + ': ' + why.strerror +'\n' )
      continue
    if S_ISDIR ( mode ):
      processDir ( path, searcher )
    elif S_ISREG ( mode ) and re.search ( g_filePat, f ):
      global g_includeAll, g_excludeFilesPattern
      if g_includeAll or not re.search( g_excludeFilesPattern, f, re.IGNORECASE ):
        searcher ( path )

def searchFile(path):
  # TODO: look into enumerate( , 1)
  f = None
  try:
    f = open(path, "r+b")
    mem = mmap.mmap( f.fileno(), 0, prot=mmap.PROT_READ )
  except :
    return
  finally:
    if f: f.close()

  readline = mem.readline
  lineno = 0
  line = readline()
  while line:
    lineno += 1
    # TODO: this should be done using findall and colorize all matches
    # but the different result type between one (group) and (more)(groups) annoys me...
    # (one) group should have been a tuple of one instead of a string
    match = re.search( g_reg, line, g_caseFlag )
    if match:
      if g_isTty:
        matchStart = line.find(match.group(0))
        matchEnd = matchStart + len(match.group(0))
        line = line[:matchStart] + g_Col_RedStart + match.group(0) + g_Col_Reset + line[matchEnd:]
      print g_PaternFormat % (path, lineno, line),
    line = readline()
  
def grepFile(path):
  #subprocess.call ( [ "echo", "--color=always -I -n -e'%s' %s" % (g_reg, path) ], shell=False)
  #subprocess.call ( [ "cat", "./txt" ], shell=False )
  #subprocess.call ( [ "echo", "--color=always -I -n -e'bla' ./txt" ], shell=False )
# TODO: fucking shit - can't use a list to call grep !?!
  #subprocess.call ( [ "grep", "--color=always -I -n -e'bla' ./txt" ], shell=False )
  grep_out = subprocess.check_output( [ "grep --color=always -I -n -e'%s' %s" % (g_reg, path) ], shell=True )
  for line in grep_out.split( '\n' ):
    if line: print path + ':' + line

def Usage():
  global g_progname
  print '%s - Improved grep; Find expresions only in files matching a mask' % (g_progname)
  print 'Usage:'
  print '\t%s [OPTIONS]  -e|--expr= regex [-e|--expr= re [...]] [dir1 dir2 ...]' % (g_progname)
  print "\tOPTIONS: -f|--filepat= -g|--grep -p|--python -I|--includeall -h|--help\n"
  print '\t-e: Regular expresions (for grep or PCRE). Protect from shell interference'
  print '\t-f: Regular expresions that the base filenames should match (PCRE Only! not bash globbing).'
  print "\t\tProtect from shell interference. Dflt any '.*'"
  print '\t-p: Use Python regex to search in memory mapped files. Default.'
  print '\t-g: use binary grep to do the search'
  print '\t-I: Include all files that match. Usually files also matching %s are skipped' % g_excludeFilesPattern
  print '\t-h: Print this help\n'
  print 'The rest of the argumets are considered directories to perform search in. Default is .'
  print "You may place the argumet value next to the argument; eg: -eabc -e'[0-9]{2,3}\w+'. same with -f"
  print ""
  print 'TODO: add flags to easy match whole-words, case-inses, functions, defines, classes and any combination'
  print 'TODO: support multiple languages (C, Python, Makefiles ...)'
  print 'TODO: Use proper argument handling library.'

#-------------------------------------------------------------------------------

def main(av):
  
  reg = []
  filePat = []
  dirs = []
  searcher = searchFile

  global g_includeAll, g_caseFlag

  iterArgs = iter(av)
  saveMatch = DataHolder(name='match')
  for arg in iterArgs:
    if saveMatch ( re.search( r'(^-e|^--expr=)(.*)', arg ) ):
      if saveMatch.match.group(2):
        reg.append ( saveMatch.match.group(2) )
      else:
        reg.append ( iterArgs.next() )
    elif saveMatch ( re.search ( r'(^-f|^--filepat=)(.*)', arg ) ):
      if saveMatch.match.group(2):
        filePat.append ( saveMatch.match.group(2) )
      else:
        filePat.append ( iterArgs.next() )
    elif re.search ( r'^-g|^--grep', arg ):
      searcher = grepFile
    elif re.search ( r'^-p|^--python', arg ):
      searcher = searchFile
    elif re.search( r'^-I|^--includeall', arg ):
      g_includeAll = True
    elif re.search( r'^-i|^--insensitive', arg ):
      g_caseFlag = re.IGNORECASE
    elif re.search ( r'^-h|^--help', arg ):
      Usage()
      sys.exit(0)
    else:
      dirs.append ( arg )
    
  global g_reg, g_filePat
  
  if not reg :
    Usage()
    sys.exit(0)


  if searcher == grepFile: g_reg = r'\|'.join( [ '\(' + group_them + '\)' for group_them in reg] )
  else: g_reg = r'|'.join( [ '(' + group_them + ')' for group_them in reg ] )
  g_filePat = r'|'.join( [ '(' + group_them + ')' for group_them in filePat ] )
  if not dirs: dirs = ['.']
  if not g_filePat: g_filePat = r'.*'

  #print "reg found:", g_reg
  #print 'fpat:', g_filePat

  for d in dirs:
    processDir(d, searcher)


if __name__ == '__main__':
  g_progname = os.path.basename( sys.argv[0] )
  main(sys.argv[1:])
